#+TITLE: Express Ts Project Setup And Emacs

* Introduction
This is my personal setup for TS project with technology stacks beflow:
- Emacs
- Nodejs
- Typescript
- Jest
- ESlint w/ Prettier
- Docker
- Git Actions/CI for checking above setup

* Emacs IDE Setup
** ESlint
Flycheck pulls info from project config with =javascript-eslint checker=. =.prettiercr.js= will use project config and project prettier setup.
*** Prettier Automation Eslint, Prettier Middleware
I have wrote a small middleware to use =prettier-eslint= for Emacs editor. This middleware check original file if the code is linted. It uses =prettify= with =prettier-eslint=.
Check =.prettier.mjs= file.
- Eslint + Prettier
  - Run prettier middler-ware on save from emacs
    #+begin_src lisp
(add-hook 'typescript-mode-hook (lambda ()
                                  (add-hook 'after-save-hook 'run-prettier-for-ts-projects nil t)
                                  (flycheck-select-checker 'javascript-eslint)))

;; setup my custome prettier nodejs program
(defun find-my-prettier (current-path)
  (interactive)
  (message "PRETTER LOG searching directory: %s" current-path)
  (cond
   ((member ".prettier.mjs" (directory-files current-path))
    (message "PRETTER LOG FOUND FILE prettier.mjs @: %s" current-path)
    current-path)
   ((string= current-path "/") nil)
   (t (find-my-prettier (file-name-directory (directory-file-name current-path))))))

(defun run-prettier-for-ts-projects ()
  (interactive)
  (defvar running-command-parameter (concat (find-my-prettier (file-name-directory buffer-file-name)) ".prettier.mjs"))
  (defvar running-process-buffer-name "*run eslint-prettier*")
  (progn (call-process
          "node" nil "Prettier Js setup" nil
          running-command-parameter buffer-file-name)
         (revert-buffer t t t)))
    #+end_src
*** Flycheck with javascript-eslint checker
Use =javascript-eslint= and it will use project eslint configuration.

** Node Debugger
- dap mode
  - Run =M-x dap-debug= and select *complied js file*
  - features ( run with =M-x= )
    - =dap-breakpoint-toggle=
    - =dap-breakpoint-condition=
    - =dap-breakpoint-log-message=
    - =dap-delete-sessions-all=
    - =dap-disconnect=
  - installation
    In doom emacs =init.el=, enable =tools: ( debugger +lsp )= I had to manually install vscode node debugger.
    And add code:
    #+begin_src lisp
(add-hook 'typescript-mode-hook (lambda ()
                                  (require 'dap-node)
                                  (dap-node-setup)))
    #+end_src

* Testing
- jest
  - unit test
    =yarn run test:unit=
  - test with coverage
    =yarn run test:coverage=
  - jest linting setup
    #+begin_src javascript
  module.exports = {
    coverageReporters: ['json', 'json-summary', 'text', 'lcov', 'clover'],
    moduleDirectories: ['node_modules', 'src', '<rootDir>'],
    moduleFileExtensions: ['js', 'jsx', 'ts', 'tsx'],
    moduleNameMapper: {
      '^@app/(.*)$': '<rootDir>/src/$1',
    },
    preset: 'ts-jest',
    roots: ['__test__'],
    testEnvironment: 'node',
    transform: {
      '^.+\\.(ts|tsx)?$': 'ts-jest',
    },
  }
    #+end_src
    Have to setup =moduleNameMapper= to reflect a =path= setup in =tsconfig.json=
    #+begin_src json
      "paths": {
        "@app/*": ["./src/*"]
      },
    #+end_src
    The reason I included test file in compile process is to use this absolute path and LSP autocompletion.

* Building
Run =yarn run build= to build file in =dist/src= folder and this folder should always be exist even though it contains no files.
That is why package.json defines preinstall setup for creating this folder Refer to folling issue:
** =tsc= absolute path issue
When tsc build the project it cannot resolve the absolute path in tsconfig.json.
Should use =link-module-alias= for linking build files into node_module so that production files can refer to its source files from symbolic link in node_module.
#+begin_src json
"_moduleAliases": {
  "@app": "dist/src"
},
#+end_src

Alternately, next setup can do the work. But this resolves path during runtime.
#+begin_src json
"build": "tsc --p ./tsconfig.json",
"start": "ts-node -r tsconfig-paths/register ./dist/src/index.js",
#+end_src

Thus, first solution is prioritized.
There are trade-offs choosing between them:
Method 1. Should use =#= symbolic link to import modules.
Method 2. Little slower than first method.
Method 3. Use environment valuable to use Method 1 and 2. But this doesn't give us grate benefit. So Method 1 is adopted.

* Lint
- Eslint
  - Run =yarn run lint=
  - =.eslintrc.cjs= file setup
- Connect =prettierrc.js= setup with middleware =.prettier.mjs=

* Dev
Run =yarn run dev=
